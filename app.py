import os
import re
import psycopg2
import logging
from datetime import datetime
from flask import Flask, request, abort
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError, LineBotApiError
from linebot.models import MessageEvent, TextMessage, TextSendMessage, JoinEvent

# è¨­å®š Log é¡¯ç¤º (æ–¹ä¾¿é™¤éŒ¯)
logging.basicConfig(level=logging.INFO)
app = Flask(__name__)

# === 1. å¾ç’°å¢ƒè®Šæ•¸è®€å–è¨­å®š ===
LINE_CHANNEL_ACCESS_TOKEN = os.environ.get('LINE_CHANNEL_ACCESS_TOKEN')
LINE_CHANNEL_SECRET = os.environ.get('LINE_CHANNEL_SECRET')
DATABASE_URL = os.environ.get('DATABASE_URL')

# åˆå§‹åŒ– Line Bot
line_bot_api = LineBotApi(LINE_CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(LINE_CHANNEL_SECRET)

# === 2. è³‡æ–™åº«é€£ç·šè¼”åŠ©å‡½å¼ ===
def get_db_connection():
    conn = psycopg2.connect(DATABASE_URL)
    return conn

# === 3. åˆå§‹åŒ–è³‡æ–™åº« (è‡ªå‹•å»ºç«‹ä½¿ç”¨è€…è¡¨) ===
def init_db():
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        # å»ºç«‹ users è¡¨ (å¦‚æœä¸å­˜åœ¨)
        cur.execute("""
            CREATE TABLE IF NOT EXISTS users (
                user_id TEXT PRIMARY KEY,
                display_name TEXT NOT NULL
            );
        """)
        # ç¢ºä¿ expenses è¡¨å­˜åœ¨
        cur.execute("""
            CREATE TABLE IF NOT EXISTS expenses (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id TEXT NOT NULL,
                item TEXT NOT NULL,
                amount INTEGER NOT NULL,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('asia/taipei', now())
            );
        """)
        conn.commit()
        cur.close()
        conn.close()
        print("è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆï¼")
    except Exception as e:
        print(f"è³‡æ–™åº«åˆå§‹åŒ–å¤±æ•—: {e}")

# æ‡‰ç”¨ç¨‹å¼å•Ÿå‹•æ™‚åŸ·è¡Œä¸€æ¬¡åˆå§‹åŒ–
with app.app_context():
    init_db()

# === 4. è¼”åŠ©å‡½å¼ ===
# å–å¾—ç”¨æˆ¶é¡¯ç¤ºåç¨± (User ID -> Name)
def get_user_name(user_id):
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT display_name FROM users WHERE user_id = %s", (user_id,))
        result = cur.fetchone()
        cur.close()
        conn.close()
        if result:
            return result[0]
    except Exception as e:
        app.logger.error(f"æŸ¥è©¢ä½¿ç”¨è€…åç¨±å¤±æ•—: {e}")
    
    # è³‡æ–™åº«æ²’æœ‰ï¼Œè©¦è‘—å• LINE
    try:
        profile = line_bot_api.get_profile(user_id)
        return profile.display_name
    except:
        return f"ç”¨æˆ¶({user_id[:4]})"

# å–å¾—ç”¨æˆ¶ ID (Name -> User ID) - ç”¨æ–¼ã€Œå¹«åˆ¥äººè¨˜å¸³ã€
def get_user_id_by_name(name):
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT user_id FROM users WHERE display_name = %s", (name,))
        result = cur.fetchone()
        cur.close()
        conn.close()
        if result:
            return result[0]
    except Exception as e:
        app.logger.error(f"æŸ¥è©¢ ID å¤±æ•—: {e}")
    return None

@app.route("/callback", methods=['POST'])
def callback():
    signature = request.headers.get('X-Line-Signature', '')
    body = request.get_data(as_text=True)
    app.logger.info(f"Request body: {body}")

    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        app.logger.error("Invalid signature.")
        abort(400)
    return 'OK'

# === åŠ å…¥ç¾¤çµ„æ™‚çš„æ­¡è¿è© ===
@handler.add(JoinEvent)
def handle_join(event):
    welcome_msg = (
        "å¤§å®¶å¥½ï¼æˆ‘æ˜¯æƒ…ä¾¶è¨˜å¸³å°å¹«æ‰‹ â¤ï¸\n"
        "ç‚ºäº†è®“åŠŸèƒ½æ­£å¸¸é‹ä½œï¼Œè«‹å¤§å®¶å…ˆå‘Šè¨´æˆ‘ä½ æ˜¯èª°ã€‚\n\n"
        "è«‹è¼¸å…¥ï¼šæˆ‘æ˜¯ ä½ çš„åå­—\n"
        "ä¾‹å¦‚ï¼šæˆ‘æ˜¯ è€å…¬"
    )
    line_bot_api.reply_message(event.reply_token, TextSendMessage(text=welcome_msg))

@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    msg = event.message.text.strip()
    sender_id = event.source.user_id
    
    # === åŠŸèƒ½ Aï¼šè¨»å†Šåå­— (æ ¼å¼ï¼šæˆ‘æ˜¯ xxx) ===
    if msg.startswith("æˆ‘æ˜¯"):
        name = msg[2:].strip()
        if name:
            try:
                conn = get_db_connection()
                cur = conn.cursor()
                # ä½¿ç”¨ UPSERT
                cur.execute("""
                    INSERT INTO users (user_id, display_name) 
                    VALUES (%s, %s)
                    ON CONFLICT (user_id) 
                    DO UPDATE SET display_name = EXCLUDED.display_name;
                """, (sender_id, name))
                conn.commit()
                cur.close()
                conn.close()
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text=f"âœ… æ­¡è¿ {name}ï¼å·²è¨˜ä½ä½ çš„åå­—ã€‚"))
            except Exception as e:
                app.logger.error(f"è¨­å®šåå­—å¤±æ•—: {e}")
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text="âŒ è¨­å®šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚"))
        return

    # === åŠŸèƒ½ Bï¼šè¨˜å¸³ (æ™ºæ…§åˆ¤æ–·ï¼šè‡ªå·± or å¹«åˆ¥äºº) ===
    # Regex è§£æï¼š
    # Group 1 (Optional): æ—¥æœŸ (2023-12-01 æˆ– 12/01)
    # Group 2: æ–‡å­—å…§å®¹ (å¯èƒ½æ˜¯ "é …ç›®" æˆ– "åå­— é …ç›®")
    # Group 3: é‡‘é¡
    pattern = r'^(?:(\d{4}[-/]\d{1,2}[-/]\d{1,2})\s+)?(.+?)\s+(\d+)$'
    match = re.match(pattern, msg)
    
    if match:
        date_str = match.group(1)
        text_content = match.group(2).strip()
        amount = int(match.group(3))
        
        # 1. åˆ¤æ–·æ˜¯ã€Œè¨˜è‡ªå·±ã€é‚„æ˜¯ã€Œå¹«åˆ¥äººã€
        # æˆ‘å€‘æŠŠ text_content æ‹†é–‹ä¾†çœ‹ç¬¬ä¸€å€‹è©æ˜¯ä¸æ˜¯äººå
        # ä¾‹å¦‚ï¼štext_content = "è€å…¬ é£²æ–™" -> tokens = ["è€å…¬", "é£²æ–™"]
        tokens = text_content.split(None, 1)
        
        final_user_id = sender_id
        item = text_content # é è¨­æ•´å€‹æ–‡å­—éƒ½æ˜¯é …ç›® (ä¾‹å¦‚: "çç  å¥¶èŒ¶")
        
        # å¦‚æœ text_content åŒ…å«ç©ºæ ¼ (æœ‰å…©å€‹ä»¥ä¸Šçš„è©)
        if len(tokens) == 2:
            possible_name = tokens[0]
            remaining_text = tokens[1]
            
            # æŸ¥æŸ¥çœ‹ç¬¬ä¸€å€‹è©æ˜¯ä¸æ˜¯å·²è¨»å†Šçš„åå­—
            found_id = get_user_id_by_name(possible_name)
            if found_id:
                final_user_id = found_id
                item = remaining_text # é …ç›®å°±æ˜¯å‰©ä¸‹çš„å­—
                # æ‰¾åˆ°äº†ï¼é€™å°±æ˜¯ã€Œå¹«åˆ¥äººè¨˜ã€æ¨¡å¼
            else:
                # æ²’æ‰¾åˆ°åå­—ï¼Œé‚£å°±ä»£è¡¨é€™åªæ˜¯æ™®é€šçš„é …ç›®åç¨± (ä¾‹å¦‚: "çç  å¥¶èŒ¶")
                pass

        # 2. æ±ºå®šæ™‚é–“ (æŒ‡å®šæ—¥æœŸ or è‡ªå‹•ç¾åœ¨)
        created_at_val = "now()" # é è¨­ç‚º SQL çš„ now()ï¼Œè‡ªå‹•è¨˜éŒ„ç•¶ä¸‹
        display_date = "ä»Šå¤©"
        
        if date_str:
            try:
                # å˜—è©¦è§£ææ—¥æœŸ
                dt = datetime.strptime(date_str, "%Y-%m-%d")
                created_at_val = f"'{date_str} 12:00:00'" 
                display_date = date_str
            except ValueError:
                # å¦‚æœæ—¥æœŸæ ¼å¼ä¸å°ï¼Œè¦–ç‚ºæ™®é€šæ–‡å­—è¨˜å¸³å¤±æ•—? æˆ–æ˜¯æç¤º? 
                # é€™è£¡ç°¡å–®å›è¦†æç¤º
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text="âŒ æ—¥æœŸæ ¼å¼è«‹ç”¨ YYYY-MM-DD"))
                return

        # 3. å¯«å…¥è³‡æ–™åº«
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            
            if created_at_val == "now()":
                cur.execute(
                    "INSERT INTO expenses (user_id, item, amount) VALUES (%s, %s, %s)",
                    (final_user_id, item, amount)
                )
            else:
                cur.execute(
                    "INSERT INTO expenses (user_id, item, amount, created_at) VALUES (%s, %s, %s, %s)",
                    (final_user_id, item, amount, date_str)
                )
                
            conn.commit()
            
            # å–å¾—é¡¯ç¤ºç”¨çš„åå­—
            final_user_name = get_user_name(final_user_id)
            if final_user_id == sender_id:
                final_user_name = "ä½ " 

            cur.close()
            conn.close()
            
            reply_msg = f"âœ… å·²è¨˜éŒ„ï¼\nğŸ“… æ™‚é–“ï¼š{display_date}\nğŸ‘¤ ä»˜æ¬¾ï¼š{final_user_name}\nğŸ›’ é …ç›®ï¼š{item}\nğŸ’° é‡‘é¡ï¼š${amount}"
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_msg))
            
        except Exception as e:
            app.logger.error(f"Database Error: {e}")
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text="âŒ è¨˜å¸³å¤±æ•—ï¼Œè³‡æ–™åº«å‡ºéŒ¯äº†ã€‚"))
        return

    # === åŠŸèƒ½ Cï¼šæŸ¥è©¢çµç®— (åˆ—å‡ºæ˜ç´° + çµ±è¨ˆ) ===
    if msg == "çµç®—":
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            
            # 1. æ’ˆå–è©³ç´°æ˜ç´° (ä¾æ™‚é–“æ’åº)
            cur.execute("""
                SELECT e.created_at, e.user_id, e.item, e.amount 
                FROM expenses e 
                ORDER BY e.created_at ASC
            """)
            details = cur.fetchall()
            
            # 2. æ’ˆå–æ‰€æœ‰ç”¨æˆ¶å
            cur.execute("SELECT user_id, display_name FROM users")
            users_raw = cur.fetchall()
            user_map = {u[0]: u[1] for u in users_raw}
            
            cur.close()
            conn.close()
            
            if not details:
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text="ç›®å‰é‚„æ²’æœ‰ä»»ä½•æ¶ˆè²»ç´€éŒ„å–”ï¼"))
                return
            
            # === ç”¢ç”Ÿè©³ç´°æ¸…å–® ===
            reply_text = "ğŸ“ æ¶ˆè²»æ˜ç´°ï¼š\n"
            spending_map = {} # user_id -> total_amount
            total_all = 0
            
            for row in details:
                dt = row[0] # datetime object
                uid = row[1]
                item = row[2]
                amt = row[3]
                
                # ç´¯åŠ ç¸½é¡
                total_all += amt
                spending_map[uid] = spending_map.get(uid, 0) + amt
                
                # æ ¼å¼åŒ–æ—¥æœŸ (MM/DD)
                date_str = dt.strftime("%m/%d")
                name = user_map.get(uid, get_user_name(uid))
                
                reply_text += f"{date_str} {name}: {item} ${amt}\n"
            
            reply_text += "----------------\n"
            reply_text += f"ğŸ’° ç¸½æ”¯å‡º: ${total_all}\n"
            reply_text += "ğŸ“Š çµ±è¨ˆèˆ‡åˆ†å¸³ï¼š\n"
            
            # ç¢ºä¿åˆ†æ¯åŒ…å«æ‰€æœ‰è¨»å†Šç”¨æˆ¶
            for uid in user_map:
                if uid not in spending_map:
                    spending_map[uid] = 0

            user_count = len(spending_map)
            
            # === åˆ†å¸³é‚è¼¯ ===
            if user_count > 1:
                average = int(total_all / user_count)
                reply_text += f"ğŸ”¢ å¹³å‡æ¯äºº: ${average}\n\n"
                
                balances = []
                for uid, amt in spending_map.items():
                    diff = amt - average
                    balances.append({'uid': uid, 'diff': diff})
                    name = user_map.get(uid, "æœªçŸ¥")
                    reply_text += f"{name} å·²ä»˜: ${amt}\n"
                
                balances.sort(key=lambda x: x['diff'], reverse=True)
                
                transfer_text = "\nğŸ’¸ å»ºè­°è½‰å¸³ï¼š\n"
                i = 0 
                j = len(balances) - 1
                has_transfer = False

                while i < j:
                    creditor = balances[i]
                    debtor = balances[j]
                    
                    if int(creditor['diff']) == 0:
                        i += 1
                        continue
                    if int(debtor['diff']) == 0:
                        j -= 1
                        continue
                    
                    amount = min(creditor['diff'], -debtor['diff'])
                    amount_int = int(amount)
                    
                    if amount_int > 0:
                        debtor_name = user_map.get(debtor['uid'], "æœªçŸ¥")
                        creditor_name = user_map.get(creditor['uid'], "æœªçŸ¥")
                        transfer_text += f"ğŸ‘‰ {debtor_name} çµ¦ {creditor_name} ${amount_int}\n"
                        has_transfer = True
                    
                    balances[i]['diff'] -= amount
                    balances[j]['diff'] += amount
                
                if not has_transfer:
                    transfer_text += "ç›®å‰æ¬¾é …å·²å¹³è¡¡ï¼"
                
                reply_text += transfer_text
            else:
                reply_text += f"\n(ç›®å‰åªæœ‰ 1 ä½ç”¨æˆ¶åƒèˆ‡è¨˜å¸³ï¼Œç„¡æ³•åˆ†å¸³)"

            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_text))

        except Exception as e:
            app.logger.error(f"Error: {e}")
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text="âŒ çµç®—ç™¼ç”ŸéŒ¯èª¤"))
        return

    # === åŠŸèƒ½ Dï¼šæ¸…é™¤æ‰€æœ‰è³‡æ–™ (æŒ‡ä»¤ï¼šæ¸…é™¤) ===
    if msg == "æ¸…é™¤":
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute("DELETE FROM expenses")
            conn.commit()
            cur.close()
            conn.close()
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text="ğŸ—‘ï¸ å·²æ¸…é™¤æ‰€æœ‰è¨˜å¸³è³‡æ–™ï¼\nä¸€åˆ‡é‡æ–°é–‹å§‹ âœ¨"))
        except Exception as e:
            app.logger.error(f"DB Error: {e}")
        return

@app.route("/", methods=['GET'])
def health_check():
    return "Bot is running!", 200

if __name__ == "__main__":
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port)
