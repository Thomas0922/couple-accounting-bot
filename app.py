import os
import re
import psycopg2
from psycopg2 import pool
import logging
from datetime import datetime
from flask import Flask, request, abort
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError, LineBotApiError
from linebot.models import (
    MessageEvent, TextMessage, TextSendMessage, JoinEvent, FollowEvent,
    QuickReply, QuickReplyButton, MessageAction  # â† Quick Reply ç›¸é—œ
)

# è¨­å®š Log é¡¯ç¤º
logging.basicConfig(level=logging.INFO)
app = Flask(__name__)

# === ç’°å¢ƒè®Šæ•¸ ===
LINE_CHANNEL_ACCESS_TOKEN = os.environ.get('LINE_CHANNEL_ACCESS_TOKEN')
LINE_CHANNEL_SECRET = os.environ.get('LINE_CHANNEL_SECRET')
DATABASE_URL = os.environ.get('DATABASE_URL')

line_bot_api = LineBotApi(LINE_CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(LINE_CHANNEL_SECRET)

# === ğŸ¨ Quick Reply åŠŸèƒ½ ===
def create_quick_reply_buttons():
    """å»ºç«‹å¿«é€Ÿå›è¦†æŒ‰éˆ•"""
    return QuickReply(items=[
        QuickReplyButton(
            action=MessageAction(label="æ—©é¤", text="æ—©é¤")
        ),
        QuickReplyButton(
            action=MessageAction(label="åˆé¤", text="åˆé¤")
        ),
        QuickReplyButton(
            action=MessageAction(label="æ™šé¤", text="æ™šé¤")
        ),
        QuickReplyButton(
            action=MessageAction(label="é£²æ–™", text="é£²æ–™")
        ),
        QuickReplyButton(
            action=MessageAction(label="äº¤é€š", text="äº¤é€š")
        ),
        QuickReplyButton(
            action=MessageAction(label="å¨›æ¨‚", text="å¨›æ¨‚")
        ),
        QuickReplyButton(
            action=MessageAction(label="çµç®—", text="çµç®—")
        ),
        QuickReplyButton(
            action=MessageAction(label="èªªæ˜", text="èªªæ˜")
        )
    ])

# === è³‡æ–™åº«é€£ç·šæ±  ===
connection_pool = None

def get_connection_pool():
    global connection_pool
    if connection_pool is None:
        connection_pool = psycopg2.pool.SimpleConnectionPool(1, 10, DATABASE_URL)
    return connection_pool

def get_db_connection():
    try:
        pool = get_connection_pool()
        return pool.getconn()
    except Exception as e:
        app.logger.error(f"é€£ç·šæ± éŒ¯èª¤: {e}")
        return psycopg2.connect(DATABASE_URL)

def return_db_connection(conn):
    try:
        pool = get_connection_pool()
        pool.putconn(conn)
    except:
        if conn:
            conn.close()

# === æ­¡è¿è¨Šæ¯ ===
WELCOME_MSG = (
    "ğŸ‘‹ å¤§å®¶å¥½ï¼æˆ‘æ˜¯æƒ…ä¾¶è¨˜å¸³å°å¹«æ‰‹\n\n"
    "âœ¨ åˆæ¬¡è¦‹é¢è«‹å…ˆè¨»å†Šï¼š\n"
    "ğŸ‘‰ è¼¸å…¥ã€Œæˆ‘æ˜¯ ä½ çš„åå­—ã€\n"
    "(ä¾‹å¦‚ï¼šæˆ‘æ˜¯ è€å…¬)\n\n"
    "ğŸ“ ã€æŒ‡ä»¤å¤§å…¨ã€‘\n"
    "1. è¨˜è‡ªå·± (æœ€å¸¸ç”¨)ï¼š\n"
    "   â€¢ æ™šé¤ 200\n"
    "   â€¢ é£²æ–™50 (ä¸ç”¨ç©ºæ ¼)\n\n"
    "2. è‡ªå‹•æ‹†å¸³ï¼š\n"
    "   â€¢ æ™šé¤ 400 å¹« 150\n\n"
    "3. çµç®—èˆ‡æŸ¥è©¢ï¼š\n"
    "   â€¢ çµç®—ï¼šçœ‹æ‰€æœ‰äººæ˜ç´°\n"
    "   â€¢ è€å…¬ çµç®—ï¼šåªçœ‹è€å…¬çš„\n\n"
    "4. ä¿®æ”¹èˆ‡åˆªé™¤ï¼š\n"
    "   â€¢ ç§»é™¤ é£²æ–™ï¼šåˆªé™¤æœ€æ–°ä¸€ç­†ã€Œé£²æ–™ã€\n"
    "   â€¢ ç§»é™¤æœ€å¾Œä¸€ç­†ï¼šåˆªé™¤å‰›å‰›è¨˜çš„é‚£ç­†\n"
    "   â€¢ æ¸…é™¤ï¼šå…¨éƒ¨åˆªå…‰å…‰\n\n"
    "ğŸ’¡ å°æŠ€å·§ï¼š\n"
    "è¨˜å¸³å¾Œæœƒå‡ºç¾å¿«é€ŸæŒ‰éˆ•ï¼Œé»æ“Šå³å¯å¿«é€Ÿè¨˜å¸³ï¼"
)

# === è³‡æ–™åº«åˆå§‹åŒ– ===
_db_initialized = False

def init_db():
    global _db_initialized
    if _db_initialized:
        return
    
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            CREATE TABLE IF NOT EXISTS users (
                user_id TEXT PRIMARY KEY,
                display_name TEXT NOT NULL
            );
        """)
        
        cur.execute("""
            CREATE TABLE IF NOT EXISTS expenses (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id TEXT NOT NULL,
                item TEXT NOT NULL,
                amount INTEGER NOT NULL,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('asia/taipei', now())
            );
        """)
        
        cur.execute("CREATE INDEX IF NOT EXISTS idx_expenses_user_id ON expenses(user_id);")
        cur.execute("CREATE INDEX IF NOT EXISTS idx_expenses_created_at ON expenses(created_at);")
        cur.execute("CREATE INDEX IF NOT EXISTS idx_expenses_user_created ON expenses(user_id, created_at);")
        
        conn.commit()
        cur.close()
        return_db_connection(conn)
        _db_initialized = True
        app.logger.info("è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆï¼")
    except Exception as e:
        app.logger.error(f"è³‡æ–™åº«åˆå§‹åŒ–å¤±æ•—: {e}")
        if conn:
            return_db_connection(conn)

# === è¼”åŠ©å‡½å¼ ===
def get_user_name(user_id, conn=None):
    should_close = False
    if conn is None:
        conn = get_db_connection()
        should_close = True
    
    try:
        cur = conn.cursor()
        cur.execute("SELECT display_name FROM users WHERE user_id = %s", (user_id,))
        result = cur.fetchone()
        cur.close()
        if result:
            return result[0]
    except Exception as e:
        app.logger.error(f"æŸ¥è©¢ä½¿ç”¨è€…åç¨±å¤±æ•—: {e}")
    finally:
        if should_close:
            return_db_connection(conn)
    
    try:
        profile = line_bot_api.get_profile(user_id)
        return profile.display_name
    except:
        return f"ç”¨æˆ¶({user_id[:4]})"

def get_user_id_by_name(name):
    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT user_id FROM users WHERE display_name = %s", (name,))
        result = cur.fetchone()
        cur.close()
        if result:
            return result[0]
    except Exception as e:
        app.logger.error(f"æŸ¥è©¢ ID å¤±æ•—: {e}")
    finally:
        if conn:
            return_db_connection(conn)
    return None

def get_partner_id(my_user_id):
    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT user_id, display_name FROM users WHERE user_id != %s", (my_user_id,))
        rows = cur.fetchall()
        cur.close()
        if len(rows) == 1:
            return rows[0][0], rows[0][1]
    except Exception as e:
        app.logger.error(f"æŸ¥è©¢å¦ä¸€åŠå¤±æ•—: {e}")
    finally:
        if conn:
            return_db_connection(conn)
    return None, None

@app.route("/callback", methods=['POST'])
def callback():
    init_db()
    signature = request.headers.get('X-Line-Signature', '')
    body = request.get_data(as_text=True)
    app.logger.info(f"Request body: {body}")

    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        app.logger.error("Invalid signature.")
        abort(400)
    return 'OK'

@handler.add(FollowEvent)
def handle_follow(event):
    line_bot_api.reply_message(
        event.reply_token, 
        TextSendMessage(
            text=WELCOME_MSG,
            quick_reply=create_quick_reply_buttons()  # â† åŠ å…¥å¥½å‹æ™‚ä¹Ÿé¡¯ç¤ºå¿«é€ŸæŒ‰éˆ•
        )
    )

@handler.add(JoinEvent)
def handle_join(event):
    line_bot_api.reply_message(
        event.reply_token,
        TextSendMessage(
            text=WELCOME_MSG,
            quick_reply=create_quick_reply_buttons()  # â† åŠ å…¥ç¾¤çµ„æ™‚ä¹Ÿé¡¯ç¤ºå¿«é€ŸæŒ‰éˆ•
        )
    )

@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    msg = event.message.text.strip()
    sender_id = event.source.user_id

    # === å°å½©è›‹ ===
    if msg == "æˆ‘æ„›ä½ ":
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text="æˆ‘ä¹Ÿæ„›ä½ å€‘çˆ¸çˆ¸åª½åª½ â¤ï¸",
                quick_reply=create_quick_reply_buttons()
            )
        )
        return

    # === èªªæ˜ ===
    if msg in ["èªªæ˜", "æŒ‡ä»¤", "help", "Help"]:
        line_bot_api.reply_message(
            event.reply_token,
            TextSendMessage(
                text=WELCOME_MSG,
                quick_reply=create_quick_reply_buttons()
            )
        )
        return
    
    # === è¨»å†Šåå­— ===
    if msg.startswith("æˆ‘æ˜¯"):
        name = msg[2:].strip()
        if name:
            conn = None
            try:
                conn = get_db_connection()
                cur = conn.cursor()
                cur.execute("""
                    INSERT INTO users (user_id, display_name) 
                    VALUES (%s, %s)
                    ON CONFLICT (user_id) 
                    DO UPDATE SET display_name = EXCLUDED.display_name;
                """, (sender_id, name))
                conn.commit()
                cur.close()
                line_bot_api.reply_message(
                    event.reply_token,
                    TextSendMessage(
                        text=f"âœ… æ­¡è¿ {name}ï¼å·²è¨˜ä½ä½ çš„åå­—ã€‚",
                        quick_reply=create_quick_reply_buttons()
                    )
                )
            except Exception as e:
                app.logger.error(f"è¨­å®šåå­—å¤±æ•—: {e}")
                line_bot_api.reply_message(event.reply_token, TextSendMessage(text="âŒ è¨­å®šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚"))
            finally:
                if conn:
                    return_db_connection(conn)
        return

    # === ä¸€èˆ¬è¨˜å¸³ï¼ˆç°¡åŒ–ç‰ˆï¼Œå®Œæ•´ç‰ˆè«‹åƒè€ƒåŸå§‹æª”æ¡ˆï¼‰===
    pattern_general = r'^(?:(\d{4}[-/]\d{1,2}[-/]\d{1,2})\s*)?(.+?)\s*(\d+)$'
    match = re.match(pattern_general, msg)
    
    if match:
        date_str = match.group(1)
        text_content = match.group(2).strip()
        amount = int(match.group(3))
        
        tokens = text_content.split(None, 1)
        final_user_id = sender_id
        item = text_content 
        
        if len(tokens) == 2:
            possible_name = tokens[0]
            remaining_text = tokens[1]
            found_id = get_user_id_by_name(possible_name)
            if found_id:
                final_user_id = found_id
                item = remaining_text 

        display_date = "ä»Šå¤©" if not date_str else date_str

        conn = None
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            
            if not date_str:
                cur.execute(
                    "INSERT INTO expenses (user_id, item, amount) VALUES (%s, %s, %s)",
                    (final_user_id, item, amount)
                )
            else:
                cur.execute(
                    "INSERT INTO expenses (user_id, item, amount, created_at) VALUES (%s, %s, %s, %s)",
                    (final_user_id, item, amount, date_str)
                )
                
            conn.commit()
            
            final_user_name = get_user_name(final_user_id, conn)
            if final_user_id == sender_id:
                final_user_name = "ä½ " 

            cur.close()
            
            reply_msg = f"âœ… å·²è¨˜éŒ„ï¼\nğŸ“… æ™‚é–“ï¼š{display_date}\nğŸ‘¤ ä»˜æ¬¾ï¼š{final_user_name}\nğŸ›’ é …ç›®ï¼š{item}\nğŸ’° é‡‘é¡ï¼š${amount}"
            
            # ğŸ¨ é‡é»ï¼šå›è¦†æ™‚åŠ ä¸Š Quick Reply
            line_bot_api.reply_message(
                event.reply_token,
                TextSendMessage(
                    text=reply_msg,
                    quick_reply=create_quick_reply_buttons()  # â† é€™è£¡åŠ ä¸Šå¿«é€ŸæŒ‰éˆ•
                )
            )
            
        except Exception as e:
            app.logger.error(f"Database Error: {e}")
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text="âŒ è¨˜å¸³å¤±æ•—ï¼Œè³‡æ–™åº«å‡ºéŒ¯äº†ã€‚"))
        finally:
            if conn:
                return_db_connection(conn)
        return

    # === çµç®—ï¼ˆç°¡åŒ–ç‰ˆï¼‰===
    if msg == "çµç®—":
        conn = None
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            
            cur.execute("""
                SELECT 
                    e.created_at, 
                    COALESCE(u.display_name, e.user_id) as name,
                    e.item, 
                    e.amount,
                    e.user_id
                FROM expenses e
                LEFT JOIN users u ON e.user_id = u.user_id
                ORDER BY e.created_at ASC
            """)
            details = cur.fetchall()
            
            if not details:
                line_bot_api.reply_message(
                    event.reply_token,
                    TextSendMessage(
                        text="ç›®å‰é‚„æ²’æœ‰ä»»ä½•æ¶ˆè²»ç´€éŒ„å–”ï¼",
                        quick_reply=create_quick_reply_buttons()
                    )
                )
                return
            
            cur.execute("SELECT user_id, display_name FROM users")
            users_raw = cur.fetchall()
            user_map = {u[0]: u[1] for u in users_raw}
            
            reply_text = "ğŸ“ å…¨é«”æ¶ˆè²»æ˜ç´°ï¼š\n"
            spending_map = {}
            total_all = 0
            
            for row in details:
                dt = row[0]
                name = row[1]
                item = row[2]
                amt = row[3]
                uid = row[4]
                
                total_all += amt
                spending_map[uid] = spending_map.get(uid, 0) + amt
                
                date_str = dt.strftime("%m/%d")
                reply_text += f"{date_str} {name}: {item} ${amt}\n"
            
            reply_text += "----------------\n"
            reply_text += f"ğŸ’° ç¸½æ”¯å‡º: ${total_all}\n"
            
            reply_text += "ğŸ‘¤ å„äººçµ±è¨ˆï¼š\n"
            for uid, amt in spending_map.items():
                name = user_map.get(uid, get_user_name(uid, conn))
                reply_text += f"{name}: ${amt}\n"

            cur.close()
            
            # ğŸ¨ çµç®—æ™‚ä¹ŸåŠ ä¸Š Quick Reply
            line_bot_api.reply_message(
                event.reply_token,
                TextSendMessage(
                    text=reply_text,
                    quick_reply=create_quick_reply_buttons()
                )
            )

        except Exception as e:
            app.logger.error(f"Error: {e}")
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text="âŒ çµç®—ç™¼ç”ŸéŒ¯èª¤"))
        finally:
            if conn:
                return_db_connection(conn)
        return

@app.route("/", methods=['GET'])
def health_check():
    init_db()
    return "Bot is running!", 200

if __name__ == "__main__":
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port)
