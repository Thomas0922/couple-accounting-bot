import os
import re
import psycopg2
from psycopg2 import pool
import logging
from datetime import datetime
from flask import Flask, request, abort
from linebot import LineBotApi, WebhookHandler
from linebot.exceptions import InvalidSignatureError, LineBotApiError
from linebot.models import (
    MessageEvent, TextMessage, TextSendMessage, JoinEvent, FollowEvent,
    QuickReply, QuickReplyButton, MessageAction
)

logging.basicConfig(level=logging.INFO)
app = Flask(__name__)

LINE_CHANNEL_ACCESS_TOKEN = os.environ.get('LINE_CHANNEL_ACCESS_TOKEN')
LINE_CHANNEL_SECRET = os.environ.get('LINE_CHANNEL_SECRET')
DATABASE_URL = os.environ.get('DATABASE_URL')

line_bot_api = LineBotApi(LINE_CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(LINE_CHANNEL_SECRET)

connection_pool = None

def get_connection_pool():
    global connection_pool
    if connection_pool is None:
        connection_pool = psycopg2.pool.SimpleConnectionPool(1, 10, DATABASE_URL)
    return connection_pool

def get_db_connection():
    try:
        pool = get_connection_pool()
        return pool.getconn()
    except Exception as e:
        app.logger.error(f"é€£ç·šæ± éŒ¯èª¤ï¼Œä½¿ç”¨ç›´æ¥é€£ç·š: {e}")
        return psycopg2.connect(DATABASE_URL)

def return_db_connection(conn):
    try:
        pool = get_connection_pool()
        pool.putconn(conn)
    except:
        if conn:
            conn.close()

WELCOME_MSG = (
    "ğŸ‘‹ å¤§å®¶å¥½ï¼æˆ‘æ˜¯æƒ…ä¾¶è¨˜å¸³å°å¹«æ‰‹\n\n"
    "âœ¨ åˆæ¬¡è¦‹é¢è«‹å…ˆè¨»å†Šï¼š\n"
    "ğŸ‘‰ è¼¸å…¥ã€Œæˆ‘æ˜¯ ä½ çš„åå­—ã€\n"
    "(ä¾‹å¦‚ï¼šæˆ‘æ˜¯ è€å…¬)\n\n"
    "ğŸ“ ã€æŒ‡ä»¤å¤§å…¨ã€‘\n"
    "1. è¨˜è‡ªå·± (æœ€å¸¸ç”¨)ï¼š\n"
    "   â€¢ æ™šé¤ 200\n"
    "   â€¢ é£²æ–™50 (ä¸ç”¨ç©ºæ ¼)\n\n"
    "2. è‡ªå‹•æ‹†å¸³ï¼š\n"
    "   â€¢ æ™šé¤ 400 å¹« 150\n\n"
    "3. çµç®—èˆ‡æŸ¥è©¢ï¼š\n"
    "   â€¢ çµç®—ï¼šçœ‹ç°¡æ˜“çµ±è¨ˆèˆ‡æ¬ æ¬¾\n"
    "   â€¢ è©³ç´°çµç®—ï¼šçœ‹æ‰€æœ‰æ¶ˆè²»æ˜ç´°\n"
    "   â€¢ è€å…¬ çµç®—ï¼šåªçœ‹è€å…¬çš„\n\n"
    "4. ä¿®æ”¹èˆ‡åˆªé™¤ï¼š\n"
    "   â€¢ ç§»é™¤ é£²æ–™ï¼šåˆªé™¤æœ€æ–°ä¸€ç­†ã€Œé£²æ–™ã€\n"
    "   â€¢ ç§»é™¤æœ€å¾Œä¸€ç­†ï¼šåˆªé™¤å‰›å‰›è¨˜çš„é‚£ç­†\n"
    "   â€¢ æ¸…é™¤ï¼šå…¨éƒ¨åˆªå…‰å…‰\n\n"
    "ğŸ’¡ ä½¿ç”¨ä¸‹æ–¹å¿«é€ŸæŒ‰éˆ•æ›´æ–¹ä¾¿ï¼"
)

def create_quick_reply_buttons():
    buttons = [
        QuickReplyButton(action=MessageAction(label="çµç®—", text="çµç®—")),
        QuickReplyButton(action=MessageAction(label="èªªæ˜", text="èªªæ˜")),
        QuickReplyButton(action=MessageAction(label="ç§»é™¤æœ€å¾Œä¸€ç­†", text="ç§»é™¤æœ€å¾Œä¸€ç­†"))
    ]
    
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT display_name FROM users ORDER BY user_id LIMIT 2")
        users = cur.fetchall()
        cur.close()
        return_db_connection(conn)
        
        for user in users:
            user_name = user[0]
            buttons.append(
                QuickReplyButton(
                    action=MessageAction(label=f"{user_name} çµç®—", text=f"{user_name} çµç®—")
                )
            )
    except Exception as e:
        app.logger.error(f"å»ºç«‹å¿«é€ŸæŒ‰éˆ•å¤±æ•—: {e}")
    
    return QuickReply(items=buttons)

_db_initialized = False

def init_db():
    global _db_initialized
    if _db_initialized:
        return
        
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        
        cur.execute("""
            CREATE TABLE IF NOT EXISTS users (
                user_id TEXT PRIMARY KEY,
                display_name TEXT NOT NULL
            );
        """)
        
        cur.execute("""
            CREATE TABLE IF NOT EXISTS expenses (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id TEXT NOT NULL,
                item TEXT NOT NULL,
                amount INTEGER NOT NULL,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('asia/taipei', now())
            );
        """)
        
        cur.execute("CREATE INDEX IF NOT EXISTS idx_expenses_user_id ON expenses(user_id);")
        cur.execute("CREATE INDEX IF NOT EXISTS idx_expenses_created_at ON expenses(created_at);")
        cur.execute("CREATE INDEX IF NOT EXISTS idx_expenses_user_created ON expenses(user_id, created_at);")
        
        conn.commit()
        cur.close()
        return_db_connection(conn)
        _db_initialized = True
        app.logger.info("è³‡æ–™åº«åˆå§‹åŒ–å®Œæˆï¼")
    except Exception as e:
        app.logger.error(f"è³‡æ–™åº«åˆå§‹åŒ–å¤±æ•—: {e}")
        if conn:
            return_db_connection(conn)

def get_user_name(user_id, conn=None):
    should_close = False
    if conn is None:
        conn = get_db_connection()
        should_close = True
    
    try:
        cur = conn.cursor()
        cur.execute("SELECT display_name FROM users WHERE user_id = %s", (user_id,))
        result = cur.fetchone()
        cur.close()
        
        if result:
            return result[0]
    except Exception as e:
        app.logger.error(f"æŸ¥è©¢ä½¿ç”¨è€…åç¨±å¤±æ•—: {e}")
    finally:
        if should_close:
            return_db_connection(conn)
    
    try:
        profile = line_bot_api.get_profile(user_id)
        return profile.display_name
    except:
        return f"ç”¨æˆ¶({user_id[:4]})"

def get_user_id_by_name(name):
    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT user_id FROM users WHERE display_name = %s", (name,))
        result = cur.fetchone()
        cur.close()
        if result:
            return result[0]
    except Exception as e:
        app.logger.error(f"æŸ¥è©¢ ID å¤±æ•—: {e}")
    finally:
        if conn:
            return_db_connection(conn)
    return None

def get_partner_id(my_user_id):
    conn = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT user_id, display_name FROM users WHERE user_id != %s", (my_user_id,))
        rows = cur.fetchall()
        cur.close()
        
        if len(rows) == 1:
            return rows[0][0], rows[0][1]
    except Exception as e:
        app.logger.error(f"æŸ¥è©¢å¦ä¸€åŠå¤±æ•—: {e}")
    finally:
        if conn:
            return_db_connection(conn)
    return None, None

def calculate_debts(conn):
    """
    è¨ˆç®—æ¬ æ¬¾é—œä¿‚
    è¿”å›: {debtor_name: {creditor_name: amount}}
    """
    try:
        cur = conn.cursor()
        
        # ç²å–æ‰€æœ‰ä½¿ç”¨è€…æ˜ å°„
        cur.execute("SELECT user_id, display_name FROM users")
        users = {row[0]: row[1] for row in cur.fetchall()}
        
        # æŸ¥æ‰¾æ‰€æœ‰åŒ…å« "(éœ€çµ¦XXX)" çš„é …ç›®
        cur.execute("""
            SELECT user_id, item, amount
            FROM expenses
            WHERE item LIKE '%(éœ€çµ¦%)'
        """)
        
        debt_records = cur.fetchall()
        cur.close()
        
        # åˆå§‹åŒ–æ¬ æ¬¾å­—å…¸
        debts = {}
        
        # è§£ææ¯ç­†æ¬ æ¬¾è¨˜éŒ„
        for user_id, item, amount in debt_records:
            # æå–å‚µæ¬Šäººåå­— (å¾ "é …ç›® (éœ€çµ¦XXX)" ä¸­æå– XXX)
            match = re.search(r'\(éœ€çµ¦(.+?)\)', item)
            if match:
                creditor_name = match.group(1)
                debtor_name = users.get(user_id, user_id)
                
                # åˆå§‹åŒ–å‚µå‹™äººå­—å…¸
                if debtor_name not in debts:
                    debts[debtor_name] = {}
                
                # ç´¯åŠ æ¬ æ¬¾
                if creditor_name not in debts[debtor_name]:
                    debts[debtor_name][creditor_name] = 0
                debts[debtor_name][creditor_name] += amount
        
        return debts
        
    except Exception as e:
        app.logger.error(f"è¨ˆç®—æ¬ æ¬¾å¤±æ•—: {e}")
        return {}

@app.route("/callback", methods=['POST'])
def callback():
    init_db()
    
    signature = request.headers.get('X-Line-Signature', '')
    body = request.get_data(as_text=True)
    app.logger.info(f"Request body: {body}")

    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        app.logger.error("Invalid signature.")
        abort(400)
    return 'OK'

@handler.add(FollowEvent)
def handle_follow(event):
    line_bot_api.reply_message(
        event.reply_token, 
        TextSendMessage(text=WELCOME_MSG, quick_reply=create_quick_reply_buttons())
    )

@handler.add(JoinEvent)
def handle_join(event):
    line_bot_api.reply_message(
        event.reply_token, 
        TextSendMessage(text=WELCOME_MSG, quick_reply=create_quick_reply_buttons())
    )

@handler.add(MessageEvent, message=TextMessage)
def handle_message(event):
    msg = event.message.text.strip()
    sender_id = event.source.user_id

    if msg == "æˆ‘æ„›ä½ ":
        line_bot_api.reply_message(
            event.reply_token, 
            TextSendMessage(text="æˆ‘ä¹Ÿæ„›ä½ å€‘çˆ¸çˆ¸åª½åª½ â¤ï¸", quick_reply=create_quick_reply_buttons())
        )
        return

    if msg in ["èªªæ˜", "æŒ‡ä»¤", "help", "Help"]:
        line_bot_api.reply_message(
            event.reply_token, 
            TextSendMessage(text=WELCOME_MSG, quick_reply=create_quick_reply_buttons())
        )
        return
    
    if msg.startswith("æˆ‘æ˜¯"):
        name = msg[2:].strip()
        if name:
            conn = None
            try:
                conn = get_db_connection()
                cur = conn.cursor()
                cur.execute("""
                    INSERT INTO users (user_id, display_name) 
                    VALUES (%s, %s)
                    ON CONFLICT (user_id) 
                    DO UPDATE SET display_name = EXCLUDED.display_name;
                """, (sender_id, name))
                conn.commit()
                cur.close()
                line_bot_api.reply_message(
                    event.reply_token, 
                    TextSendMessage(text=f"âœ… æ­¡è¿ {name}ï¼å·²è¨˜ä½ä½ çš„åå­—ã€‚", quick_reply=create_quick_reply_buttons())
                )
            except Exception as e:
                app.logger.error(f"è¨­å®šåå­—å¤±æ•—: {e}")
                line_bot_api.reply_message(
                    event.reply_token, 
                    TextSendMessage(text="âŒ è¨­å®šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚", quick_reply=create_quick_reply_buttons())
                )
            finally:
                if conn:
                    return_db_connection(conn)
        return

    if msg == "ç§»é™¤æœ€å¾Œä¸€ç­†":
        conn = None
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute("SELECT id, user_id, amount, item, created_at FROM expenses ORDER BY created_at DESC LIMIT 1")
            row = cur.fetchone()
            if row:
                cur.execute("DELETE FROM expenses WHERE id = %s", (row[0],))
                conn.commit()
                name = get_user_name(row[1], conn)
                date_str = row[4].strftime("%m/%d")
                reply_text = f"ğŸ—‘ï¸ å·²ç§»é™¤æœ€æ–°ä¸€ç­†ç´€éŒ„ï¼š\n{date_str} {name}: {row[3]} ${row[2]}"
            else:
                reply_text = "ğŸ“­ ç›®å‰æ²’æœ‰ä»»ä½•ç´€éŒ„å¯ä»¥ç§»é™¤å–”ï¼"
            cur.close()
            line_bot_api.reply_message(
                event.reply_token, 
                TextSendMessage(text=reply_text, quick_reply=create_quick_reply_buttons())
            )
        except Exception as e:
            app.logger.error(f"DB Error: {e}")
            line_bot_api.reply_message(
                event.reply_token,
                TextSendMessage(text="âŒ ç§»é™¤å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚", quick_reply=create_quick_reply_buttons())
            )
        finally:
            if conn:
                return_db_connection(conn)
        return

    match_remove = re.match(r'^ç§»é™¤\s+(.+)$', msg)
    if match_remove:
        item_to_remove = match_remove.group(1).strip()
        conn = None
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute("""
                SELECT id, user_id, amount, created_at 
                FROM expenses 
                WHERE item = %s 
                ORDER BY created_at DESC 
                LIMIT 1
            """, (item_to_remove,))
            row = cur.fetchone()
            
            if row:
                cur.execute("DELETE FROM expenses WHERE id = %s", (row[0],))
                conn.commit()
                name = get_user_name(row[1], conn)
                date_str = row[3].strftime("%m/%d")
                reply_text = f"ğŸ—‘ï¸ å·²ç§»é™¤ï¼š\n{date_str} {name}: {item_to_remove} ${row[2]}"
            else:
                reply_text = f"âŒ æ‰¾ä¸åˆ°åç¨±ç‚ºã€Œ{item_to_remove}ã€çš„ç´€éŒ„ï¼"
            
            cur.close()
            line_bot_api.reply_message(
                event.reply_token, 
                TextSendMessage(text=reply_text, quick_reply=create_quick_reply_buttons())
            )
        except Exception as e:
            app.logger.error(f"DB Error: {e}")
            line_bot_api.reply_message(
                event.reply_token,
                TextSendMessage(text="âŒ ç§»é™¤å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚", quick_reply=create_quick_reply_buttons())
            )
        finally:
            if conn:
                return_db_connection(conn)
        return

    pattern_split_explicit = r'^(?:(\d{4}[-/]\d{1,2}[-/]\d{1,2})\s*)?(.+?)\s*(\d+)\s*å¹«\s*(.+?)\s*(\d+)$'
    pattern_split_implicit = r'^(?:(\d{4}[-/]\d{1,2}[-/]\d{1,2})\s*)?(.+?)\s*(\d+)\s*å¹«\s*(\d+)$'
    
    match_explicit = re.match(pattern_split_explicit, msg)
    match_implicit = re.match(pattern_split_implicit, msg)
    
    if match_explicit or match_implicit:
        target_user_id = None
        target_user_name = None
        sender_name = get_user_name(sender_id)

        if match_implicit:
            date_str = match_implicit.group(1)
            item = match_implicit.group(2).strip()
            total_amount = int(match_implicit.group(3))
            split_amount = int(match_implicit.group(4))
            
            target_user_id, target_user_name = get_partner_id(sender_id)
            if not target_user_id:
                line_bot_api.reply_message(
                    event.reply_token, 
                    TextSendMessage(
                        text="âŒ ç„¡æ³•è‡ªå‹•åˆ¤æ–·å°è±¡ï¼\nå¦‚æœæ˜¯å¤šäººä½¿ç”¨ï¼Œè«‹æŒ‡å®šåå­—ï¼š\nä¾‹å¦‚ï¼šæ™šé¤ 400 å¹« è€å…¬ 150",
                        quick_reply=create_quick_reply_buttons()
                    )
                )
                return
        elif match_explicit:
            date_str = match_explicit.group(1)
            item = match_explicit.group(2).strip()
            total_amount = int(match_explicit.group(3))
            target_name_input = match_explicit.group(4).strip()
            split_amount = int(match_explicit.group(5))
            
            target_user_id = get_user_id_by_name(target_name_input)
            if target_user_id:
                target_user_name = target_name_input
            else:
                line_bot_api.reply_message(
                    event.reply_token, 
                    TextSendMessage(
                        text=f"âŒ æ‰¾ä¸åˆ°ã€Œ{target_name_input}ã€ï¼\nè«‹ç¢ºèªå°æ–¹æœ‰è¼¸å…¥ã€Œæˆ‘æ˜¯ {target_name_input}ã€è¨»å†Šéã€‚",
                        quick_reply=create_quick_reply_buttons()
                    )
                )
                return

        self_amount = total_amount - split_amount
        created_at_val = "now()"
        display_date = "ä»Šå¤©"
        if date_str:
            try:
                datetime.strptime(date_str, "%Y-%m-%d")
                created_at_val = f"'{date_str} 12:00:00'"
                display_date = date_str
            except ValueError:
                line_bot_api.reply_message(
                    event.reply_token, 
                    TextSendMessage(text="âŒ æ—¥æœŸæ ¼å¼è«‹ç”¨ YYYY-MM-DD", quick_reply=create_quick_reply_buttons())
                )
                return

        conn = None
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            
            sql = "INSERT INTO expenses (user_id, item, amount, created_at) VALUES (%s, %s, %s, " + created_at_val + ")" if created_at_val != "now()" else "INSERT INTO expenses (user_id, item, amount) VALUES (%s, %s, %s)"
            
            cur.execute(sql, (sender_id, item, self_amount))
            note_item = f"{item} (éœ€çµ¦{sender_name})"
            cur.execute(sql, (target_user_id, note_item, split_amount))
            
            conn.commit()
            cur.close()
            
            reply_text = (
                f"âœ… è‡ªå‹•æ‹†å¸³å®Œæˆï¼\n"
                f"ğŸ“… æ™‚é–“ï¼š{display_date}\n"
                f"ğŸ›’ é …ç›®ï¼š{item} (ç¸½é¡ ${total_amount})\n"
                f"----------------\n"
                f"ğŸ‘¤ {sender_name}ï¼š${self_amount}\n"
                f"ğŸ‘¤ {target_user_name}ï¼š${split_amount}"
            )
            line_bot_api.reply_message(
                event.reply_token, 
                TextSendMessage(text=reply_text, quick_reply=create_quick_reply_buttons())
            )
            
        except Exception as e:
            app.logger.error(f"DB Error: {e}")
            line_bot_api.reply_message(
                event.reply_token, 
                TextSendMessage(text="âŒ æ‹†å¸³å¤±æ•—ï¼Œè³‡æ–™åº«éŒ¯èª¤", quick_reply=create_quick_reply_buttons())
            )
        finally:
            if conn:
                return_db_connection(conn)
        return

    pattern_general = r'^(?:(\d{4}[-/]\d{1,2}[-/]\d{1,2})\s*)?(.+?)\s*(\d+)$'
    match = re.match(pattern_general, msg)
    
    if match:
        date_str = match.group(1)
        text_content = match.group(2).strip()
        amount = int(match.group(3))
        
        tokens = text_content.split(None, 1)
        final_user_id = sender_id
        item = text_content 
        
        if len(tokens) == 2:
            possible_name = tokens[0]
            remaining_text = tokens[1]
            found_id = get_user_id_by_name(possible_name)
            if found_id:
                final_user_id = found_id
                item = remaining_text 

        created_at_val = "now()" 
        display_date = "ä»Šå¤©"
        if date_str:
            try:
                datetime.strptime(date_str, "%Y-%m-%d")
                created_at_val = f"'{date_str} 12:00:00'" 
                display_date = date_str
            except ValueError:
                line_bot_api.reply_message(
                    event.reply_token, 
                    TextSendMessage(text="âŒ æ—¥æœŸæ ¼å¼è«‹ç”¨ YYYY-MM-DD", quick_reply=create_quick_reply_buttons())
                )
                return

        conn = None
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            
            if created_at_val == "now()":
                cur.execute(
                    "INSERT INTO expenses (user_id, item, amount) VALUES (%s, %s, %s)",
                    (final_user_id, item, amount)
                )
            else:
                cur.execute(
                    "INSERT INTO expenses (user_id, item, amount, created_at) VALUES (%s, %s, %s, %s)",
                    (final_user_id, item, amount, date_str)
                )
                
            conn.commit()
            
            final_user_name = get_user_name(final_user_id, conn)
            if final_user_id == sender_id:
                final_user_name = "ä½ " 

            cur.close()
            
            reply_msg = f"âœ… å·²è¨˜éŒ„ï¼\nğŸ“… æ™‚é–“ï¼š{display_date}\nğŸ‘¤ ä»˜æ¬¾ï¼š{final_user_name}\nğŸ›’ é …ç›®ï¼š{item}\nğŸ’° é‡‘é¡ï¼š${amount}"
            line_bot_api.reply_message(
                event.reply_token, 
                TextSendMessage(text=reply_msg, quick_reply=create_quick_reply_buttons())
            )
            
        except Exception as e:
            app.logger.error(f"Database Error: {e}")
            line_bot_api.reply_message(
                event.reply_token, 
                TextSendMessage(text="âŒ è¨˜å¸³å¤±æ•—ï¼Œè³‡æ–™åº«å‡ºéŒ¯äº†ã€‚", quick_reply=create_quick_reply_buttons())
            )
        finally:
            if conn:
                return_db_connection(conn)
        return

    # === çµç®—åŠŸèƒ½ï¼ˆæ”¯æ´ç°¡æ˜“èˆ‡è©³ç´°æ¨¡å¼ï¼‰===
    match_settle = re.match(r'^(?:(.+?)\s*)?(è©³ç´°)?çµç®—$', msg)
    
    if match_settle:
        specific_name = match_settle.group(1)
        is_detailed = match_settle.group(2) == "è©³ç´°"
        conn = None
        
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            
            # === å€‹äººçµç®— ===
            if specific_name:
                target_uid = get_user_id_by_name(specific_name)
                
                if specific_name == "æˆ‘":
                    target_uid = sender_id
                    specific_name = get_user_name(sender_id, conn)

                if not target_uid:
                     line_bot_api.reply_message(
                         event.reply_token, 
                         TextSendMessage(
                             text=f"âŒ æ‰¾ä¸åˆ°ã€Œ{specific_name}ã€ï¼è«‹ç¢ºèªåå­—æœ‰è¨»å†Šéã€‚",
                             quick_reply=create_quick_reply_buttons()
                         )
                     )
                     return

                cur.execute("""
                    SELECT created_at, item, amount 
                    FROM expenses 
                    WHERE user_id = %s
                    ORDER BY created_at ASC
                """, (target_uid,))
                details = cur.fetchall()
                
                if not details:
                     line_bot_api.reply_message(
                         event.reply_token, 
                         TextSendMessage(
                             text=f"ğŸ‘¤ {specific_name} ç›®å‰é‚„æ²’æœ‰æ¶ˆè²»ç´€éŒ„å–”ï¼",
                             quick_reply=create_quick_reply_buttons()
                         )
                     )
                     return

                reply_text = f"ğŸ‘¤ {specific_name} çš„æ¶ˆè²»æ˜ç´°ï¼š\n"
                total = 0
                for row in details:
                    dt = row[0]
                    item = row[1]
                    amt = row[2]
                    total += amt
                    date_str = dt.strftime("%m/%d")
                    reply_text += f"{date_str}: {item} ${amt}\n"
                
                reply_text += "----------------\n"
                reply_text += f"ğŸ’° å€‹äººç¸½æ”¯å‡º: ${total}"

            # === å…¨é«”çµç®— ===
            else:
                cur.execute("""
                    SELECT 
                        e.created_at, 
                        COALESCE(u.display_name, e.user_id) as name,
                        e.item, 
                        e.amount,
                        e.user_id
                    FROM expenses e
                    LEFT JOIN users u ON e.user_id = u.user_id
                    ORDER BY e.created_at ASC
                """)
                details = cur.fetchall()
                
                if not details:
                    line_bot_api.reply_message(
                        event.reply_token, 
                        TextSendMessage(
                            text="ç›®å‰é‚„æ²’æœ‰ä»»ä½•æ¶ˆè²»ç´€éŒ„å–”ï¼",
                            quick_reply=create_quick_reply_buttons()
                        )
                    )
                    return
                
                cur.execute("SELECT user_id, display_name FROM users")
                users_raw = cur.fetchall()
                user_map = {u[0]: u[1] for u in users_raw}
                
                spending_map = {}
                total_all = 0
                
                # è¨ˆç®—å„äººç¸½æ”¯å‡º
                for row in details:
                    amt = row[3]
                    uid = row[4]
                    total_all += amt
                    spending_map[uid] = spending_map.get(uid, 0) + amt
                
                # ç¢ºä¿æ‰€æœ‰è¨»å†Šç”¨æˆ¶éƒ½åœ¨ spending_map ä¸­
                for uid in user_map:
                    if uid not in spending_map:
                        spending_map[uid] = 0
                
                # è¨ˆç®—æ¬ æ¬¾
                debts = calculate_debts(conn)
                
                # === ç°¡æ˜“æ¨¡å¼ï¼ˆé è¨­ï¼‰===
                if not is_detailed:
                    reply_text = "ğŸ“Š ç°¡æ˜“çµç®—å ±è¡¨\n"
                    reply_text += "================\n"
                    reply_text += f"ğŸ’° ç¸½æ”¯å‡º: ${total_all}\n\n"
                    
                    reply_text += "ğŸ‘¤ å„äººçµ±è¨ˆï¼š\n"
                    for uid, amt in spending_map.items():
                        name = user_map.get(uid, get_user_name(uid, conn))
                        reply_text += f"{name}: ${amt}\n"
                    
                    # é¡¯ç¤ºæ¬ æ¬¾é—œä¿‚
                    if debts:
                        reply_text += "\nğŸ’³ æ¬ æ¬¾é—œä¿‚ï¼š\n"
                        for debtor, creditors in debts.items():
                            for creditor, amount in creditors.items():
                                reply_text += f"{debtor} æ¬  {creditor}: ${amount}\n"
                    else:
                        reply_text += "\nâœ¨ ç›®å‰æ²’æœ‰æœªçµæ¸…çš„æ¬ æ¬¾ï¼"
                    
                    reply_text += "\nğŸ’¡ è¼¸å…¥ã€Œè©³ç´°çµç®—ã€æŸ¥çœ‹å®Œæ•´æ˜ç´°"
                
                # === è©³ç´°æ¨¡å¼ ===
                else:
                    reply_text = "ğŸ“ è©³ç´°æ¶ˆè²»æ˜ç´°ï¼š\n"
                    
                    # æŒ‰æ—¥æœŸåˆ†çµ„
                    daily_records = {}
                    for row in details:
                        dt = row[0]
                        date_key = dt.strftime("%Y-%m-%d")
                        if date_key not in daily_records:
                            daily_records[date_key] = []
                        daily_records[date_key].append(row)
                    
                    # æŒ‰æ—¥æœŸæ’åºï¼ˆæœ€è¿‘çš„åœ¨å‰ï¼‰
                    sorted_dates = sorted(daily_records.keys(), reverse=True)
                    
                    # æœ€å¤šé¡¯ç¤ºæœ€è¿‘ 15 å¤©
                    display_dates = sorted_dates[:15]
                    
                    for date in display_dates:
                        dt_obj = datetime.strptime(date, "%Y-%m-%d")
                        date_display = dt_obj.strftime("%m/%d (%a)")
                        
                        # æ—¥æœŸæ¨™é¡Œ
                        reply_text += f"\nğŸ“… {date_display}\n"
                        reply_text += "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
                        
                        # è©²æ—¥çš„æ‰€æœ‰è¨˜éŒ„
                        daily_total = 0
                        for row in daily_records[date]:
                            name = row[1]
                            item = row[2]
                            amt = row[3]
                            daily_total += amt
                            reply_text += f"  {name}: {item} ${amt}\n"
                        
                        # æ¯æ—¥å°è¨ˆ
                        reply_text += f"  ğŸ’° ç•¶æ—¥å°è¨ˆ: ${daily_total}\n"
                    
                    if len(sorted_dates) > 15:
                        reply_text += f"\n... é‚„æœ‰ {len(sorted_dates) - 15} å¤©çš„è¨˜éŒ„æœªé¡¯ç¤º\n"
                    
                    reply_text += "\n================\n"
                    reply_text += f"ğŸ’° ç¸½æ”¯å‡º: ${total_all}\n\n"
                    
                    reply_text += "ğŸ‘¤ å„äººçµ±è¨ˆï¼š\n"
                    for uid, amt in spending_map.items():
                        name = user_map.get(uid, get_user_name(uid, conn))
                        reply_text += f"  {name}: ${amt}\n"
                    
                    # é¡¯ç¤ºæ¬ æ¬¾é—œä¿‚
                    if debts:
                        reply_text += "\nğŸ’³ æ¬ æ¬¾é—œä¿‚ï¼š\n"
                        for debtor, creditors in debts.items():
                            for creditor, amount in creditors.items():
                                reply_text += f"  {debtor} æ¬  {creditor}: ${amount}\n"

            cur.close()
            line_bot_api.reply_message(
                event.reply_token, 
                TextSendMessage(text=reply_text, quick_reply=create_quick_reply_buttons())
            )

        except Exception as e:
            app.logger.error(f"Error: {e}")
            line_bot_api.reply_message(
                event.reply_token, 
                TextSendMessage(text="âŒ çµç®—ç™¼ç”ŸéŒ¯èª¤", quick_reply=create_quick_reply_buttons())
            )
        finally:
            if conn:
                return_db_connection(conn)
        return

    if msg == "æ¸…é™¤":
        conn = None
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute("DELETE FROM expenses")
            conn.commit()
            cur.close()
            line_bot_api.reply_message(
                event.reply_token, 
                TextSendMessage(
                    text="ğŸ—‘ï¸ å·²æ¸…é™¤æ‰€æœ‰è¨˜å¸³è³‡æ–™ï¼\nä¸€åˆ‡é‡æ–°é–‹å§‹ âœ¨",
                    quick_reply=create_quick_reply_buttons()
                )
            )
        except Exception as e:
            app.logger.error(f"DB Error: {e}")
            line_bot_api.reply_message(
                event.reply_token,
                TextSendMessage(text="âŒ æ¸…é™¤å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚", quick_reply=create_quick_reply_buttons())
            )
        finally:
            if conn:
                return_db_connection(conn)
        return
    
    # === é è¨­å›è¦†ï¼šç•¶è¨Šæ¯ä¸ç¬¦åˆä»»ä½•æŒ‡ä»¤æ™‚ ===
    line_bot_api.reply_message(
        event.reply_token,
        TextSendMessage(
            text="â“ æˆ‘ä¸å¤ªæ‡‚ä½ çš„æ„æ€\nè«‹é»é¸ä¸‹æ–¹æŒ‰éˆ•æˆ–è¼¸å…¥ã€Œèªªæ˜ã€æŸ¥çœ‹æŒ‡ä»¤",
            quick_reply=create_quick_reply_buttons()
        )
    )

@app.route("/", methods=['GET'])
def health_check():
    init_db()
    return "Bot is running!", 200

if __name__ == "__main__":
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port)
